---
# Role: environment_setup
# Description: Prepares environment for benchmark execution (directories, lock file, cleanup)

- name: Log environment setup phase
  ansible.builtin.debug:
    msg: "========== Environment Setup Phase =========="

- name: Ensure workspace root directory exists
  ansible.builtin.file:
    path: "{{ benchmark_workspace_root }}"
    state: directory
    mode: '0755'
  become: yes

- name: Install rsync (required for artifact synchronization)
  ansible.builtin.package:
    name: rsync
    state: present
  become: yes

- name: Clone or update gas-benchmarks repository
  ansible.builtin.git:
    repo: "{{ benchmark_source_repo }}"
    dest: "{{ benchmark_workspace_root }}/{{ benchmark_source_dir }}"
    version: "{{ benchmark_source_branch }}"
    force: yes

- name: Install git-lfs package (Debian/Ubuntu)
  ansible.builtin.apt:
    name: git-lfs
    state: present
    update_cache: yes
  become: yes
  when: ansible_os_family == "Debian"

- name: Install git-lfs package (RedHat/CentOS)
  ansible.builtin.yum:
    name: git-lfs
    state: present
  become: yes
  when: ansible_os_family == "RedHat"

- name: Install git-lfs package (macOS)
  community.general.homebrew:
    name: git-lfs
    state: present
  when: ansible_os_family == "Darwin"

- name: Pull LFS files for gas-benchmarks
  ansible.builtin.shell: |
    git lfs install
    git lfs pull
  args:
    chdir: "{{ benchmark_workspace_root }}/{{ benchmark_source_dir }}"
    executable: /bin/bash
  register: lfs_pull_result
  changed_when: "'Downloading' in lfs_pull_result.stdout or 'Filtering' in lfs_pull_result.stdout"

# =============================================================================
# yq Installation (YAML processor)
# Used for clean YAML modifications (e.g., Nethermind docker-compose patching)
# =============================================================================
- name: Check if yq is installed
  ansible.builtin.command: yq --version
  register: yq_version_result
  changed_when: false
  failed_when: false

- name: Install yq (Debian/Ubuntu)
  ansible.builtin.shell: |
    YQ_VERSION=$(curl -s https://api.github.com/repos/mikefarah/yq/releases/latest | grep tag_name | cut -d '"' -f 4)
    curl -Lo /usr/local/bin/yq "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64"
    chmod +x /usr/local/bin/yq
  args:
    executable: /bin/bash
  become: yes
  when:
    - yq_version_result.rc != 0
    - ansible_os_family == "Debian"

- name: Install yq (RedHat/CentOS)
  ansible.builtin.shell: |
    YQ_VERSION=$(curl -s https://api.github.com/repos/mikefarah/yq/releases/latest | grep tag_name | cut -d '"' -f 4)
    curl -Lo /usr/local/bin/yq "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64"
    chmod +x /usr/local/bin/yq
  args:
    executable: /bin/bash
  become: yes
  when:
    - yq_version_result.rc != 0
    - ansible_os_family == "RedHat"

- name: Install yq (macOS)
  community.general.homebrew:
    name: yq
    state: present
  when:
    - yq_version_result.rc != 0
    - ansible_os_family == "Darwin"

- name: Log yq status
  ansible.builtin.debug:
    msg: "âœ“ yq {{ 'installed' if yq_version_result.rc != 0 else 'already present' }}"

# =============================================================================
# Dotnet SDK Installation
# Required for Nethermind.Tools.Kute benchmark tooling
# =============================================================================
- name: Check if dotnet is installed
  ansible.builtin.command: dotnet --version
  register: dotnet_version_result
  changed_when: false
  failed_when: false

- name: Parse dotnet version
  ansible.builtin.set_fact:
    dotnet_version: "{{ dotnet_version_result.stdout | regex_search('([0-9]+\\.[0-9]+)', '\\1') | first }}"
  when: dotnet_version_result.rc == 0

- name: Determine if dotnet installation needed
  ansible.builtin.set_fact:
    dotnet_install_needed: "{{ (dotnet_version_result.rc != 0) or (dotnet_version is defined and dotnet_version is version(min_dotnet_version, '<')) }}"

- name: Add Microsoft package repository key (Ubuntu only)
  ansible.builtin.shell: |
    set -e
    UBUNTU_VERSION=$(lsb_release -rs)
    TEMP_DEB=$(mktemp)
    wget -q "https://packages.microsoft.com/config/ubuntu/${UBUNTU_VERSION}/packages-microsoft-prod.deb" -O "$TEMP_DEB"
    if [ ! -s "$TEMP_DEB" ]; then
      echo "Error: Failed to download Microsoft repository package" >&2
      rm -f "$TEMP_DEB"
      exit 1
    fi
    dpkg -i "$TEMP_DEB"
    rm -f "$TEMP_DEB"
  args:
    executable: /bin/bash
  become: yes
  when:
    - dotnet_install_needed | bool
    - ansible_distribution == "Ubuntu"
  register: microsoft_repo_result
  changed_when: microsoft_repo_result.rc == 0

- name: Update apt cache after adding Microsoft repository
  ansible.builtin.apt:
    update_cache: yes
  become: yes
  when:
    - dotnet_install_needed | bool
    - ansible_distribution == "Ubuntu"
    - microsoft_repo_result is changed

- name: Install dotnet SDK using dotnet-install script
  ansible.builtin.shell: |
    set -e
    TEMP_SCRIPT=$(mktemp)
    wget -q https://dot.net/v1/dotnet-install.sh -O "$TEMP_SCRIPT"
    if [ ! -s "$TEMP_SCRIPT" ]; then
      echo "Error: Failed to download dotnet-install script" >&2
      rm -f "$TEMP_SCRIPT"
      exit 1
    fi
    chmod +x "$TEMP_SCRIPT"
    "$TEMP_SCRIPT" --channel {{ min_dotnet_version }} --install-dir /usr/share/dotnet
    rm -f "$TEMP_SCRIPT"
    # Force update symlink to point to newly installed dotnet
    rm -f /usr/bin/dotnet
    ln -s /usr/share/dotnet/dotnet /usr/bin/dotnet
  args:
    executable: /bin/bash
  become: yes
  when: dotnet_install_needed | bool
  register: dotnet_install_result
  changed_when: "'Already installed' not in dotnet_install_result.stdout"

- name: Verify dotnet installation succeeded
  ansible.builtin.command: dotnet --version
  register: dotnet_verify_result
  changed_when: false
  failed_when: dotnet_verify_result.rc != 0
  when: dotnet_install_result is changed

- name: Parse dotnet version after installation
  ansible.builtin.set_fact:
    dotnet_version: "{{ dotnet_verify_result.stdout | regex_search('([0-9]+\\.[0-9]+)', '\\1') | first }}"
  when: dotnet_install_result is changed

- name: Log dotnet status
  ansible.builtin.debug:
    msg: "âœ“ Dotnet SDK {{ dotnet_version | default('not installed') }}"
  when: dotnet_version is defined

# =============================================================================
# UV Package Manager Installation
# Fast Python package manager used for installing benchmark dependencies
# =============================================================================
- name: Check if uv is installed
  ansible.builtin.command: uv --version
  register: uv_version_result
  changed_when: false
  failed_when: false

- name: Install uv if not present
  ansible.builtin.shell: |
    curl -LsSf https://astral.sh/uv/install.sh | sh
  environment:
    SHELL: /bin/bash
  when: uv_version_result.rc != 0
  register: uv_installer_result

- name: Log uv installation result
  ansible.builtin.debug:
    msg: "âœ“ UV package manager {{ 'installed' if uv_installer_result is changed else 'already present' }}"

# =============================================================================
# Python Dependencies Installation
# Install benchmark script dependencies from requirements.txt
# =============================================================================
- name: Install Python dependencies using uv
  ansible.builtin.shell: |
    set -e
    # Try multiple possible uv locations
    UV_CMD=""
    if command -v uv &> /dev/null; then
      UV_CMD="uv"
    elif [ -f "$HOME/.cargo/bin/uv" ]; then
      UV_CMD="$HOME/.cargo/bin/uv"
    elif [ -f "$HOME/.local/bin/uv" ]; then
      UV_CMD="$HOME/.local/bin/uv"
    else
      # Try adding common paths and check again
      export PATH="$HOME/.cargo/bin:$HOME/.local/bin:$PATH"
      if command -v uv &> /dev/null; then
        UV_CMD="uv"
      fi
    fi

    if [ -z "$UV_CMD" ]; then
      echo "Error: UV package manager not found. Ensure ~/.cargo/bin or ~/.local/bin is in PATH." >&2
      exit 1
    fi

    $UV_CMD venv
    $UV_CMD pip install -r requirements.txt
  args:
    chdir: "{{ benchmark_workspace_root }}/{{ benchmark_source_dir }}"
    executable: /bin/bash
  register: pip_install_result
  changed_when: "'Already satisfied' not in pip_install_result.stdout"

- name: Log Python dependencies status
  ansible.builtin.debug:
    msg: "âœ“ Python packages installed via UV {{ '(newly installed)' if pip_install_result.changed else '(already satisfied)' }}"

# =============================================================================
# Makefile Tools Preparation
# Build Nethermind.Tools.Kute for benchmark execution
# =============================================================================
- name: Check if Makefile exists in source directory
  ansible.builtin.stat:
    path: "{{ benchmark_workspace_root }}/{{ benchmark_source_dir }}/Makefile"
  register: makefile_stat

- name: Check if Nethermind repo already cloned
  ansible.builtin.stat:
    path: "{{ benchmark_workspace_root }}/{{ benchmark_source_dir }}/nethermind"
  register: nethermind_repo_stat
  when: makefile_stat.stat.exists


- name: Notify about long-running tools preparation
  ansible.builtin.debug:
    msg:
      - "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      - "â³ STARTING TOOLS PREPARATION (first run can take up to 10 minutes)"
      - "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      - "{{ 'ðŸ“¦ Step 1/3: Cloning Nethermind repo (~1GB) - this takes the longest' if not (nethermind_repo_stat.stat.exists | default(false)) else 'âœ“ Nethermind repo already exists, skipping clone' }}"
      - "{{ 'ðŸ“¦ Step 2/3: Pulling LFS files' if not (nethermind_repo_stat.stat.exists | default(false)) else 'âœ“ LFS files already pulled' }}"
      - "ðŸ”¨ Step 3/3: Building Nethermind.Tools.Kute (dotnet restore + compile)"
      - "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      - "Please wait..."
  when:
    - makefile_stat.stat.exists
    - dotnet_version is defined

- name: Prepare tools via Makefile (requires dotnet)
  ansible.builtin.command:
    cmd: make prepare_tools
    chdir: "{{ benchmark_workspace_root }}/{{ benchmark_source_dir }}"
  register: make_prepare_result
  changed_when: "'up to date' not in make_prepare_result.stdout"
  failed_when: make_prepare_result.rc != 0
  when:
    - makefile_stat.stat.exists
    - dotnet_version is defined

- name: Log tools preparation summary
  ansible.builtin.debug:
    msg: "âœ“ Tools preparation completed {{ '(new build)' if make_prepare_result.changed else '(already up to date)' }}"
  when:
    - makefile_stat.stat.exists
    - dotnet_version is defined
    - make_prepare_result is defined

# =============================================================================
# Directory Cleanup and Creation
# =============================================================================
- name: Clean previous results directories
  ansible.builtin.file:
    path: "{{ benchmark_workspace_root }}/{{ item }}"
    state: absent
  loop:
    - "{{ benchmark_results_dir }}"
    - "{{ benchmark_preparation_results_dir }}"
    - "{{ benchmark_source_dir }}/reports"

- name: Create required directories
  ansible.builtin.file:
    path: "{{ benchmark_workspace_root }}/{{ item }}"
    state: directory
    mode: '0755'
  loop:
    - "{{ benchmark_results_dir }}"
    - "{{ benchmark_warmup_results_dir }}"
    - "{{ benchmark_reports_dir }}"
    - "{{ benchmark_logs_dir }}"
    - "{{ benchmark_preparation_results_dir }}"

- name: Clean up stale overlay mounts (if using overlays)
  ansible.builtin.shell: |
    set -e

    # Find all overlay mounts under the overlay runtime directory
    overlay_runtime_path="{{ benchmark_workspace_root }}/{{ benchmark_overlay_tmp_root }}"

    if [ -d "$overlay_runtime_path" ]; then
      # Find and unmount all overlay filesystems
      find "$overlay_runtime_path" -type d -name "overlay" 2>/dev/null | while read mount_point; do
        if mountpoint -q "$mount_point" 2>/dev/null; then
          echo "Unmounting stale overlay: $mount_point"
          sudo umount "$mount_point" 2>/dev/null || {
            echo "Failed to unmount $mount_point, attempting lazy unmount"
            sudo umount -l "$mount_point" 2>/dev/null || true
          }
        fi
      done

      # Clean up the overlay runtime directory
      rm -rf "$overlay_runtime_path"
    fi

    echo "Overlay cleanup completed"
  args:
    executable: /bin/bash
  when: benchmark_overlay_enabled | default(false)
  register: overlay_cleanup_result
  changed_when: "'Unmounting' in overlay_cleanup_result.stdout"
  failed_when: false
