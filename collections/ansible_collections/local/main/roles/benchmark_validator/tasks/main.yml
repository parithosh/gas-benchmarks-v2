---
# Role: benchmark_validator
# Description: Validates prerequisites and configuration before benchmark execution

- name: Log prerequisite validation phase
  ansible.builtin.debug:
    msg: "========== Prerequisite Validation Phase =========="

- name: Validate Docker is installed
  ansible.builtin.command: docker --version
  register: docker_version_result
  changed_when: false
  failed_when: docker_version_result.rc != 0

- name: Parse Docker version
  ansible.builtin.set_fact:
    docker_version: "{{ docker_version_result.stdout | regex_search('([0-9]+\\.[0-9]+)', '\\1') | first }}"

- name: Log Docker validation result
  ansible.builtin.debug:
    msg: "âœ“ Docker validated: {{ docker_version_result.stdout }}"

- name: Fail if Docker version is too old
  ansible.builtin.fail:
    msg: "Docker not installed or version too old (found: {{ docker_version }}, required: >= 20.10)"
  when: docker_version is version('20.10', '<')

- name: Validate Docker Compose is installed
  ansible.builtin.command: docker compose version
  register: docker_compose_version_result
  changed_when: false
  failed_when: docker_compose_version_result.rc != 0

- name: Parse Docker Compose version
  ansible.builtin.set_fact:
    docker_compose_version: "{{ docker_compose_version_result.stdout | regex_search('v?([0-9]+\\.[0-9]+)', '\\1') | first }}"

- name: Fail if Docker Compose version is too old
  ansible.builtin.fail:
    msg: "Docker Compose not installed or version too old (found: {{ docker_compose_version }}, required: >= 2.0)"
  when: docker_compose_version is version('2.0', '<')

- name: Validate Docker daemon is running
  ansible.builtin.command: docker ps
  register: docker_ps_result
  changed_when: false
  failed_when: docker_ps_result.rc != 0

- name: Fail if Docker daemon is not running
  ansible.builtin.fail:
    msg: "Docker daemon not running or permission denied"
  when: docker_ps_result.rc != 0

- name: Log Docker daemon validation result
  ansible.builtin.debug:
    msg: "âœ“ Docker daemon running"

- name: Test Docker Hub connectivity
  ansible.builtin.command: docker pull --quiet hello-world
  register: docker_hub_result
  changed_when: false
  failed_when: false
  timeout: 60

- name: Warn if Docker Hub is not reachable
  ansible.builtin.debug:
    msg: "âš ï¸  WARNING: Could not pull from Docker Hub. Benchmark images may fail to download. Check network/firewall settings."
  when: docker_hub_result.rc != 0

- name: Log Docker Hub connectivity result
  ansible.builtin.debug:
    msg: "âœ“ Docker Hub connectivity verified"
  when: docker_hub_result.rc == 0

- name: Check if port 8545 (JSON-RPC) is available
  ansible.builtin.wait_for:
    port: 8545
    state: stopped
    timeout: 1
  register: port_8545_result
  failed_when: false

- name: Check if port 8551 (Engine API) is available
  ansible.builtin.wait_for:
    port: 8551
    state: stopped
    timeout: 1
  register: port_8551_result
  failed_when: false

- name: Warn if benchmark ports are in use
  ansible.builtin.debug:
    msg: "âš ï¸  WARNING: Ports 8545 or 8551 may be in use. This could cause conflicts during benchmarking."
  when: (port_8545_result.failed | default(false)) or (port_8551_result.failed | default(false))

- name: Log port availability result
  ansible.builtin.debug:
    msg: "âœ“ Ports 8545/8551 are available"
  when: not (port_8545_result.failed | default(false)) and not (port_8551_result.failed | default(false))

- name: Validate Python is installed
  ansible.builtin.command: python3 --version
  register: python_version_result
  changed_when: false
  failed_when: python_version_result.rc != 0

- name: Parse Python version
  ansible.builtin.set_fact:
    python_version: "{{ python_version_result.stdout | regex_search('([0-9]+\\.[0-9]+)', '\\1') | first }}"

- name: Log Python validation result
  ansible.builtin.debug:
    msg: "âœ“ Python validated: {{ python_version_result.stdout }}"

- name: Fail if Python version is too old
  ansible.builtin.fail:
    msg: "Python 3.10+ not installed (found: {{ python_version }})"
  when: python_version is version('3.10', '<')

- name: Validate jq is installed
  ansible.builtin.command: jq --version
  register: jq_version_result
  changed_when: false
  failed_when: jq_version_result.rc != 0

- name: Log jq validation result
  ansible.builtin.debug:
    msg: "âœ“ jq validated: {{ jq_version_result.stdout }}"

- name: Fail if jq is not installed
  ansible.builtin.fail:
    msg: "jq not installed (required for JSON processing)"
  when: jq_version_result.rc != 0

- name: Check if dotnet is installed
  ansible.builtin.command: dotnet --version
  register: dotnet_version_result
  changed_when: false
  failed_when: false

- name: Parse dotnet version
  ansible.builtin.set_fact:
    dotnet_version: "{{ dotnet_version_result.stdout | regex_search('([0-9]+\\.[0-9]+)', '\\1') | first }}"
  when: dotnet_version_result.rc == 0

- name: Determine if dotnet installation needed
  ansible.builtin.set_fact:
    dotnet_install_needed: "{{ (dotnet_version_result.rc != 0) or (dotnet_version is defined and dotnet_version is version(min_dotnet_version, '<')) }}"

- name: Add Microsoft package repository key (Ubuntu only)
  ansible.builtin.shell: |
    set -e
    UBUNTU_VERSION=$(lsb_release -rs)
    TEMP_DEB=$(mktemp)
    wget -q "https://packages.microsoft.com/config/ubuntu/${UBUNTU_VERSION}/packages-microsoft-prod.deb" -O "$TEMP_DEB"
    if [ ! -s "$TEMP_DEB" ]; then
      echo "Error: Failed to download Microsoft repository package" >&2
      rm -f "$TEMP_DEB"
      exit 1
    fi
    dpkg -i "$TEMP_DEB"
    rm -f "$TEMP_DEB"
  args:
    executable: /bin/bash
  become: yes
  when:
    - dotnet_install_needed | bool
    - ansible_distribution == "Ubuntu"
  register: microsoft_repo_result
  changed_when: microsoft_repo_result.rc == 0

- name: Update apt cache after adding Microsoft repository
  ansible.builtin.apt:
    update_cache: yes
  become: yes
  when:
    - dotnet_install_needed | bool
    - ansible_distribution == "Ubuntu"
    - microsoft_repo_result is changed

- name: Install dotnet SDK 9.0 using dotnet-install script
  ansible.builtin.shell: |
    set -e
    TEMP_SCRIPT=$(mktemp)
    wget -q https://dot.net/v1/dotnet-install.sh -O "$TEMP_SCRIPT"
    if [ ! -s "$TEMP_SCRIPT" ]; then
      echo "Error: Failed to download dotnet-install script" >&2
      rm -f "$TEMP_SCRIPT"
      exit 1
    fi
    chmod +x "$TEMP_SCRIPT"
    "$TEMP_SCRIPT" --channel 9.0 --install-dir /usr/share/dotnet
    rm -f "$TEMP_SCRIPT"
    # Force update symlink to point to newly installed dotnet 9
    rm -f /usr/bin/dotnet
    ln -s /usr/share/dotnet/dotnet /usr/bin/dotnet
  args:
    executable: /bin/bash
  become: yes
  when:
    - dotnet_install_needed | bool
  register: dotnet_install_result_script
  changed_when: "'Already installed' not in dotnet_install_result_script.stdout"

- name: Set dotnet install result
  ansible.builtin.set_fact:
    dotnet_install_result: "{{ dotnet_install_result_script }}"
  when: dotnet_install_needed | bool

- name: Verify dotnet installation succeeded
  ansible.builtin.command: dotnet --version
  register: dotnet_verify_result
  changed_when: false
  failed_when: dotnet_verify_result.rc != 0
  when: dotnet_install_result_script is changed

- name: Parse dotnet version after installation
  ansible.builtin.set_fact:
    dotnet_version: "{{ dotnet_verify_result.stdout | regex_search('([0-9]+\\.[0-9]+)', '\\1') | first }}"
  when: dotnet_install_result_script is changed

- name: Log dotnet validation result
  ansible.builtin.debug:
    msg: "âœ“ Dotnet validated: {{ dotnet_version }}"
  when: dotnet_version is defined

- name: Check available disk space
  ansible.builtin.shell: |
    df -k {{ workspace_root }} | tail -1 | awk '{print $4}'
  register: disk_space_kb_result
  changed_when: false
  failed_when: false

- name: Convert disk space to GB
  ansible.builtin.set_fact:
    disk_space_gb: "{{ (disk_space_kb_result.stdout | int / 1024 / 1024) | round(1, 'floor') | int }}"

- name: Log disk space check result
  ansible.builtin.debug:
    msg: "âœ“ Disk space validated: {{ disk_space_gb }}G available"

- name: Warn if disk space is low
  ansible.builtin.debug:
    msg: "WARNING: Low disk space detected ({{ disk_space_gb }}G available). Benchmarks may require 10G+ for results and logs."
  when: disk_space_gb | int < 10

- name: Fail if disk space is critically low
  ansible.builtin.fail:
    msg: "Insufficient disk space ({{ disk_space_gb }}G available, minimum 5G required)"
  when: disk_space_gb | int < 5

- name: Validate run.sh exists and is executable
  ansible.builtin.stat:
    path: "{{ workspace_root }}/{{ benchmark_source_dir }}/run.sh"
  register: run_sh_stat

- name: Fail if run.sh not found
  ansible.builtin.fail:
    msg: "{{ benchmark_source_dir }}/run.sh not found (check benchmark_source_dir variable)"
  when: not run_sh_stat.stat.exists

- name: Fail if run.sh is not executable
  ansible.builtin.fail:
    msg: "{{ benchmark_source_dir }}/run.sh exists but is not executable"
  when: run_sh_stat.stat.exists and not run_sh_stat.stat.executable

- name: Validate setup_node.py exists
  ansible.builtin.stat:
    path: "{{ workspace_root }}/{{ benchmark_source_dir }}/setup_node.py"
  register: setup_node_stat

- name: Fail if setup_node.py not found
  ansible.builtin.fail:
    msg: "{{ benchmark_source_dir }}/setup_node.py not found"
  when: not setup_node_stat.stat.exists

- name: Validate requirements.txt exists
  ansible.builtin.stat:
    path: "{{ workspace_root }}/{{ benchmark_source_dir }}/requirements.txt"
  register: requirements_stat

- name: Fail if requirements.txt not found
  ansible.builtin.fail:
    msg: "{{ benchmark_source_dir }}/requirements.txt not found"
  when: not requirements_stat.stat.exists

- name: Validate client directories exist
  ansible.builtin.stat:
    path: "{{ workspace_root }}/{{ benchmark_source_dir }}/scripts/{{ item }}"
  register: client_dir_stats
  loop: "{{ benchmark_clients }}"
  failed_when: not client_dir_stats.stat.exists

- name: Fail if client directory not found
  ansible.builtin.fail:
    msg: "Client directory not found: {{ benchmark_source_dir }}/scripts/{{ item.item }}"
  when: not item.stat.exists
  loop: "{{ client_dir_stats.results }}"
  loop_control:
    label: "{{ item.item }}"

- name: Validate client docker-compose.yaml exists
  ansible.builtin.stat:
    path: "{{ workspace_root }}/{{ benchmark_source_dir }}/scripts/{{ item }}/docker-compose.yaml"
  register: docker_compose_stats
  loop: "{{ benchmark_clients }}"

- name: Fail if docker-compose.yaml not found for client
  ansible.builtin.fail:
    msg: "docker-compose.yaml not found for client {{ item.item }}"
  when: not item.stat.exists
  loop: "{{ docker_compose_stats.results }}"
  loop_control:
    label: "{{ item.item }}"

- name: Validate test paths exist
  ansible.builtin.stat:
    path: "{{ workspace_root }}/{{ item.path }}"
  register: test_path_stats
  loop: "{{ benchmark_test_paths }}"
  loop_control:
    label: "{{ item.path }}"

- name: Fail if test path not found
  ansible.builtin.fail:
    msg: "Test path not found: {{ item.item.path }}"
  when: not item.stat.exists
  loop: "{{ test_path_stats.results }}"
  loop_control:
    label: "{{ item.item.path }}"

- name: Validate warmup file exists (if specified)
  ansible.builtin.stat:
    path: "{{ workspace_root }}/{{ benchmark_warmup_file }}"
  register: warmup_file_stat
  when: benchmark_warmup_file is defined and benchmark_warmup_file != ""

- name: Fail if warmup file not found
  ansible.builtin.fail:
    msg: "Warmup file not found: {{ benchmark_warmup_file }}"
  when:
    - benchmark_warmup_file is defined
    - benchmark_warmup_file != ""
    - not warmup_file_stat.stat.exists

- name: Normalize benchmark_clients to ensure it's a list  
  block:
    - name: Convert Python list string to JSON and parse
      ansible.builtin.set_fact:
        benchmark_clients_normalized: "{{ benchmark_clients | replace(\"'\", '\"') | from_json }}"
      when: benchmark_clients is string
    
    - name: Use benchmark_clients as-is if it's already a list
      ansible.builtin.set_fact:
        benchmark_clients_normalized: "{{ benchmark_clients }}"
      when: benchmark_clients is not string

- name: Validate genesis files exist for each client
  ansible.builtin.stat:
    path: "{{ workspace_root }}/{{ benchmark_source_dir }}/scripts/genesisfiles/{{ item[0] }}/{{ item[1].genesis }}"
  register: genesis_file_stats
  loop: "{{ benchmark_clients_normalized | product(benchmark_test_paths | selectattr('genesis', 'defined') | list) | list }}"
  loop_control:
    label: "{{ item[0] }}/{{ item[1].genesis }}"
  when: item[1].genesis is defined

- name: Fail if genesis file not found
  ansible.builtin.fail:
    msg: "Genesis file not found: {{ item.item[1].genesis }} for client {{ item.item[0] }}"
  when: not item.stat.exists
  loop: "{{ genesis_file_stats.results }}"
  loop_control:
    label: "{{ item.item[0] }}/{{ item.item[1].genesis }}"

- name: Check if uv is installed
  ansible.builtin.command: uv --version
  register: uv_version_result
  changed_when: false
  failed_when: false

- name: Install uv if not present
  ansible.builtin.shell: |
    curl -LsSf https://astral.sh/uv/install.sh | sh
  environment:
    SHELL: /bin/bash
  when: uv_version_result.rc != 0
  register: uv_installer_result

- name: Log uv installation result
  ansible.builtin.debug:
    msg: "âœ“ UV package manager installed successfully"
  when: uv_installer_result is changed

- name: Install Python dependencies using uv
  ansible.builtin.shell: |
    set -e
    # Try multiple possible uv locations
    UV_CMD=""
    if command -v uv &> /dev/null; then
      UV_CMD="uv"
    elif [ -f "$HOME/.cargo/bin/uv" ]; then
      UV_CMD="$HOME/.cargo/bin/uv"
    elif [ -f "$HOME/.local/bin/uv" ]; then
      UV_CMD="$HOME/.local/bin/uv"
    else
      # Try adding common paths and check again
      export PATH="$HOME/.cargo/bin:$HOME/.local/bin:$PATH"
      if command -v uv &> /dev/null; then
        UV_CMD="uv"
      fi
    fi

    if [ -z "$UV_CMD" ]; then
      echo "Error: UV package manager not found after installation. Ensure ~/.cargo/bin or ~/.local/bin is in PATH." >&2
      exit 1
    fi

    $UV_CMD venv
    $UV_CMD pip install -r requirements.txt
  args:
    chdir: "{{ workspace_root }}/{{ benchmark_source_dir }}"
    executable: /bin/bash
  register: pip_install_result
  changed_when: "'Already satisfied' not in pip_install_result.stdout"

- name: Log package installation result
  ansible.builtin.debug:
    msg: "âœ“ Python packages installed via UV {{ '(newly installed)' if pip_install_result.changed else '(already satisfied)' }}"

- name: Check if git-lfs is installed
  ansible.builtin.command: git lfs version
  register: git_lfs_version_result
  changed_when: false
  failed_when: false

- name: Install git-lfs (Debian/Ubuntu)
  ansible.builtin.apt:
    name: git-lfs
    state: present
    update_cache: yes
  become: yes
  when:
    - git_lfs_version_result.rc != 0
    - ansible_os_family == "Debian"
  register: git_lfs_apt_result

- name: Install git-lfs (RHEL/CentOS/Fedora)
  ansible.builtin.yum:
    name: git-lfs
    state: present
  become: yes
  when:
    - git_lfs_version_result.rc != 0
    - ansible_os_family == "RedHat"
  register: git_lfs_yum_result

- name: Initialize git-lfs after installation
  ansible.builtin.command: git lfs install
  when: (git_lfs_apt_result is defined and git_lfs_apt_result is changed) or (git_lfs_yum_result is defined and git_lfs_yum_result is changed)
  changed_when: true
  register: git_lfs_init_result

- name: Log git-lfs validation result
  ansible.builtin.debug:
    msg: "âœ“ Git LFS {{ 'installed' if (git_lfs_init_result is defined and git_lfs_init_result is changed) else 'validated' }}: {{ git_lfs_version_result.stdout | default('newly installed') }}"

- name: Check if Makefile exists in source directory
  ansible.builtin.stat:
    path: "{{ workspace_root }}/{{ benchmark_source_dir }}/Makefile"
  register: makefile_stat

- name: Check if Nethermind repo already cloned
  ansible.builtin.stat:
    path: "{{ workspace_root }}/{{ benchmark_source_dir }}/nethermind"
  register: nethermind_repo_stat
  when: makefile_stat.stat.exists

- name: Notify about long-running tools preparation
  ansible.builtin.debug:
    msg:
      - "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      - "â³ STARTING TOOLS PREPARATION (first run can take up to 10 minutes)"
      - "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      - "{{ 'ğŸ“¦ Step 1/3: Cloning Nethermind repo (~1GB) - this takes the longest' if not (nethermind_repo_stat.stat.exists | default(false)) else 'âœ“ Nethermind repo already exists, skipping clone' }}"
      - "{{ 'ğŸ“¦ Step 2/3: Pulling LFS files' if not (nethermind_repo_stat.stat.exists | default(false)) else 'âœ“ LFS files already pulled' }}"
      - "ğŸ”¨ Step 3/3: Building Nethermind.Tools.Kute (dotnet restore + compile)"
      - "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      - "Please wait..."
  when:
    - makefile_stat.stat.exists
    - dotnet_version is defined

- name: Prepare tools via Makefile (requires dotnet)
  ansible.builtin.command:
    cmd: make prepare_tools
    chdir: "{{ workspace_root }}/{{ benchmark_source_dir }}"
  register: make_prepare_result
  changed_when: "'up to date' not in make_prepare_result.stdout"
  failed_when: make_prepare_result.rc != 0
  when:
    - makefile_stat.stat.exists
    - dotnet_version is defined

- name: Show tools preparation summary
  ansible.builtin.debug:
    msg: "âœ“ Tools preparation completed {{ '(new build)' if make_prepare_result.changed else '(already up to date)' }}"
  when:
    - makefile_stat.stat.exists
    - dotnet_version is defined
    - make_prepare_result is defined

- name: Register validation results
  ansible.builtin.set_fact:
    validation_results:
      docker_version: "{{ docker_version }}"
      docker_compose_version: "{{ docker_compose_version }}"
      python_version: "{{ python_version }}"
      clients_validated: "{{ benchmark_clients }}"
      test_paths_validated: "{{ benchmark_test_paths | map(attribute='path') | list }}"
      warmup_file_validated: "{{ (benchmark_warmup_file is defined and benchmark_warmup_file != '' and warmup_file_stat.stat.exists) | default(false) }}"
      genesis_files_validated: "{{ genesis_file_stats.results | default([]) | map(attribute='stat.path') | list }}"
