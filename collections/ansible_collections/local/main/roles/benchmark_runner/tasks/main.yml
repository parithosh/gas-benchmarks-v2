---
# Role: benchmark_runner
# Description: Executes gas benchmarks for a single client using run.sh script

- name: Log benchmark execution phase
  ansible.builtin.debug:
    msg: "========== Benchmark Execution Phase: {{ client_name }} =========="

- name: Log benchmark images configuration
  ansible.builtin.debug:
    msg: "benchmark_images: {{ benchmark_images | to_json }}"

- name: Clean up stale genesis files from /tmp
  ansible.builtin.file:
    path: "{{ item }}"
    state: absent
  loop:
    - /tmp/chainspec.json
  failed_when: false

# Clean execution-data directory to ensure fresh start
# This prevents stale database metadata errors (especially for Besu)
- name: Stop and remove existing Docker containers for {{ client_name }}
  ansible.builtin.shell: |
    cd "{{ workspace_root }}/{{ benchmark_source_dir }}/scripts/{{ client_name }}"
    docker compose down --volumes --remove-orphans 2>/dev/null || true
  args:
    executable: /bin/bash
  changed_when: true
  failed_when: false

- name: Remove Docker volume for {{ client_name }}
  ansible.builtin.shell: |
    # Remove the named volume if it exists
    volume_name=$(grep -E "^EC_VOLUME_NAME=" "{{ workspace_root }}/{{ benchmark_source_dir }}/scripts/{{ client_name }}/.env" 2>/dev/null | cut -d'=' -f2)
    if [ -n "$volume_name" ]; then
      docker volume rm "$volume_name" 2>/dev/null || true
    fi
    # Also try to remove common volume names
    docker volume rm "{{ client_name }}_execution_data" 2>/dev/null || true
    docker volume rm "gas-{{ client_name }}_execution_data" 2>/dev/null || true
  args:
    executable: /bin/bash
  changed_when: true
  failed_when: false

- name: Clean execution-data directory for {{ client_name }}
  ansible.builtin.shell: |
    execution_data_dir="{{ workspace_root }}/{{ benchmark_source_dir }}/scripts/{{ client_name }}/execution-data"
    if [ -d "$execution_data_dir" ]; then
      echo "Cleaning execution-data directory: $execution_data_dir"
      sudo rm -rf "$execution_data_dir"/*
      echo "Execution-data directory cleaned"
    else
      echo "Execution-data directory does not exist, creating it"
      mkdir -p "$execution_data_dir"
    fi
  args:
    executable: /bin/bash
  become: yes
  register: cleanup_result
  changed_when: "'cleaned' in cleanup_result.stdout"
  failed_when: false

- name: Log execution-data cleanup result
  ansible.builtin.debug:
    msg: "{{ cleanup_result.stdout }}"
  when: cleanup_result.stdout is defined

# Patch Nethermind docker-compose.yaml for non-performance images
# The --Blocks.CachePrecompilesOnBlockProcessing flag only exists in ethpandaops/nethermind:performance
- name: Check if using non-performance Nethermind image
  ansible.builtin.set_fact:
    nethermind_needs_patch: "{{ client_name == 'nethermind' and benchmark_images.nethermind is defined and 'performance' not in benchmark_images.nethermind }}"

- name: Patch Nethermind docker-compose.yaml for non-performance images (CachePrecompiles)
  ansible.builtin.replace:
    path: "{{ workspace_root }}/{{ benchmark_source_dir }}/scripts/nethermind/docker-compose.yaml"
    regexp: '^(\s*)-\s*--Blocks\.CachePrecompilesOnBlockProcessing=false\s*$'
    replace: '\1# - --Blocks.CachePrecompilesOnBlockProcessing=false  # Disabled for non-performance image'
  when: nethermind_needs_patch | default(false)

- name: Patch Nethermind docker-compose.yaml for non-performance images (GenesisHash)
  ansible.builtin.replace:
    path: "{{ workspace_root }}/{{ benchmark_source_dir }}/scripts/nethermind/docker-compose.yaml"
    regexp: '^(\s*)-\s*--Init\.GenesisHash=.*$'
    replace: '\1# - --Init.GenesisHash=...  # Disabled for non-performance image'
  when: nethermind_needs_patch | default(false)

- name: Execute benchmark for {{ client_name }}
  block:
    - name: Extract test path from first test (simplified for single path)
      ansible.builtin.set_fact:
        primary_test_path: "{{ benchmark_test_paths[0].path | regex_replace('^' + benchmark_tests_root + '/', '') }}"
        primary_genesis: "{{ benchmark_test_paths[0].genesis | default('') }}"

    - name: Build run.sh command (using legacy -t format)
      ansible.builtin.set_fact:
        run_command: >-
          bash run.sh
          -t "{{ primary_test_path }}"
          {{ '-g ' + primary_genesis if primary_genesis != '' else '' }}
          -c "{{ client_name }}"
          -r {{ benchmark_runs }}
          {{ '-w "' + benchmark_warmup_file + '"' if (benchmark_warmup_file is defined and benchmark_warmup_file != '') else '' }}
          {{ '-f "' + benchmark_filter + '"' if (benchmark_filter is defined and benchmark_filter != '') else '' }}
          {{ '-n "' + benchmark_network + '"' if (benchmark_network is defined and benchmark_network != '') else '' }}
          {{ '-B "' + benchmark_snapshot_root + '"' if (benchmark_snapshot_root is defined and benchmark_snapshot_root != '') else '' }}
          {{ '-R' if benchmark_restart_before_testing | default(false) else '' }}
          {{ '-F' if benchmark_skip_forkchoice | default(false) else '' }}
          {{ '-o ' + benchmark_opcodes_warmup_count | string if (benchmark_opcodes_warmup_count is defined and benchmark_opcodes_warmup_count > 0) else '' }}
          {{ "-i '" + (benchmark_images | to_json) + "'" if (benchmark_images | default({}) | length > 0) else '' }}

    - name: Log benchmark command construction
      ansible.builtin.debug:
        msg: "Benchmark command for {{ client_name }}: {{ run_command }}"

    - name: Log benchmark execution start
      ansible.builtin.debug:
        msg: "Starting benchmark execution for {{ client_name }}..."

    - name: Execute benchmark run
      ansible.builtin.shell: |
        # Activate virtualenv from workspace root (not gas-benchmarks subdirectory)
        if [ -d "{{ workspace_root }}/.venv" ]; then
          source "{{ workspace_root }}/.venv/bin/activate"
        fi
        # Run benchmark (timeout handled by async)
        {{ run_command }}
      args:
        chdir: "{{ workspace_root }}/{{ benchmark_source_dir }}"
        executable: /bin/bash
      environment:
        JWT_PATH: "{{ benchmark_jwt_path }}"
        PYTHONPATH: "{{ workspace_root }}/{{ benchmark_source_dir }}"
        PATH: "{{ workspace_root }}/.venv/bin:{{ ansible_env.PATH }}"
      register: run_result
      changed_when: true
      async: 7200
      poll: 30

    - name: Log benchmark execution end
      ansible.builtin.debug:
        msg: "Benchmark execution completed for {{ client_name }} with exit code {{ run_result.rc }}"

    - name: Check if benchmark succeeded
      ansible.builtin.assert:
        that:
          - run_result.rc == 0
        fail_msg: |
          Benchmark execution failed for {{ client_name }} (exit code: {{ run_result.rc }})

          STDERR:
          {{ run_result.stderr | default('(no stderr output)') }}

          STDOUT (last 20 lines):
          {{ (run_result.stdout | default('(no stdout output)')).split('\n')[-20:] | join('\n') }}

          NEXT STEPS:
          1. Check Docker logs: docker logs $(docker ps -aq --filter name={{ client_name }} | head -1)
          2. Check benchmark logs: cat {{ workspace_root }}/{{ benchmark_logs_dir }}/{{ client_name }}/*.log
          3. Re-run with verbose output: add -vv flag to ansible-playbook command
        success_msg: "Benchmark execution succeeded for {{ client_name }}"

    - name: Register client success
      ansible.builtin.set_fact:
        client_execution_status:
          client: "{{ client_name }}"
          status: "success"
          return_code: "{{ run_result.rc }}"
          stdout: "{{ run_result.stdout }}"

  rescue:
    - name: Log benchmark failure
      ansible.builtin.debug:
        msg: "Failed to execute benchmarks for {{ client_name }}: {{ ansible_failed_result.msg | default('Unknown error') }}"

    - name: Register client failure
      ansible.builtin.set_fact:
        client_execution_status:
          client: "{{ client_name }}"
          status: "failed"
          error_message: "{{ ansible_failed_result.msg | default('Unknown error') }}"
          return_code: "{{ run_result.rc | default(-1) }}"
          stderr: "{{ run_result.stderr | default('') }}"

    - name: Mark this client as failed
      ansible.builtin.fail:
        msg: "Benchmark execution failed for {{ client_name }}"

  always:
    - name: Collect Docker logs for client
      ansible.builtin.shell: |
        set -e
        log_dir="{{ workspace_root }}/{{ benchmark_logs_dir }}/{{ client_name }}"
        mkdir -p "$log_dir"

        # Get list of containers for this client
        containers=$(docker ps -a --filter "name={{ client_name }}" --format "{{ '{{' }}.Names{{ '}}' }}" 2>/dev/null || true)
        collected_count=0

        if [ -n "$containers" ]; then
          for container in $containers; do
            echo "Collecting logs for container: $container"
            if docker logs "$container" > "$log_dir/${container}.log" 2>&1; then
              collected_count=$((collected_count + 1))
            else
              echo "Warning: Failed to collect logs for $container" >&2
            fi
          done
          echo "Logs collected for {{ client_name }}: $collected_count containers"
        else
          echo "No containers found for {{ client_name }}"
        fi

        # Verify at least some logs were collected
        log_count=$(find "$log_dir" -name "*.log" -type f 2>/dev/null | wc -l)
        echo "Total log files in $log_dir: $log_count"
      args:
        executable: /bin/bash
      register: log_collection_result
      changed_when: "'Logs collected' in log_collection_result.stdout"
      failed_when: false

    - name: Check if reports directory exists
      ansible.builtin.stat:
        path: "{{ workspace_root }}/{{ benchmark_source_dir }}/reports"
      register: reports_dir_stat

    - name: Fail if reports directory does not exist
      ansible.builtin.fail:
        msg: |
          Benchmark failed: reports directory does not exist at {{ benchmark_source_dir }}/reports/

          This usually means the benchmark script crashed before generating any output.

          TROUBLESHOOTING:
          1. Check Docker container logs: docker logs $(docker ps -aq --filter name={{ client_name }} | head -1)
          2. Check if the client started: docker ps -a | grep {{ client_name }}
          3. Check disk space: df -h {{ workspace_root }}
          4. Check benchmark logs: ls -la {{ workspace_root }}/{{ benchmark_logs_dir }}/{{ client_name }}/

          COMMON CAUSES:
          - Client Docker image failed to pull (check network/registry access)
          - Client crashed on startup (check genesis file compatibility)
          - Insufficient disk space
          - Port conflicts (8545/8551 already in use)
      when: not reports_dir_stat.stat.exists

    - name: Check reports directory for generated artifacts
      ansible.builtin.find:
        paths: "{{ workspace_root }}/{{ benchmark_source_dir }}/reports"
        file_type: file
      register: reports_files
      when: reports_dir_stat.stat.exists

    - name: Fail if reports directory is empty
      ansible.builtin.fail:
        msg: |
          Benchmark failed: reports directory exists but contains no files at {{ benchmark_source_dir }}/reports/

          The benchmark ran but did not produce any output files.

          TROUBLESHOOTING:
          1. Check if tests matched your filter: ls {{ workspace_root }}/{{ benchmark_source_dir }}/eest_tests/ | grep -i "{{ benchmark_filter | default('') }}"
          2. Check benchmark script output: cat {{ workspace_root }}/{{ benchmark_logs_dir }}/{{ client_name }}/*.log
          3. Verify Docker container completed: docker ps -a | grep {{ client_name }}

          COMMON CAUSES:
          - Test filter "{{ benchmark_filter | default('(none)') }}" matched zero tests
          - Benchmark script exited early due to RPC connection failure
          - Client failed to sync or initialize state
      when:
        - reports_dir_stat.stat.exists
        - (reports_files.matched | default(0)) == 0

    - name: Log validation success
      ansible.builtin.debug:
        msg: "Benchmark validation passed: {{ reports_files.matched }} report files generated"
      when:
        - reports_dir_stat.stat.exists
        - reports_files.matched > 0

    - name: Copy results artifacts from gas-benchmarks to top-level
      ansible.builtin.synchronize:
        src: "{{ workspace_root }}/{{ benchmark_source_dir }}/results/"
        dest: "{{ workspace_root }}/results/"
        mode: push
        delete: no
        recursive: yes
      delegate_to: "{{ inventory_hostname }}"
      register: results_sync_result
      failed_when: false

    - name: Warn if results sync failed
      ansible.builtin.debug:
        msg: "⚠️  WARNING: Failed to sync results directory. Results may be incomplete. Check: {{ workspace_root }}/{{ benchmark_source_dir }}/results/"
      when: results_sync_result.failed | default(false)

    - name: Copy reports artifacts from gas-benchmarks to top-level
      ansible.builtin.synchronize:
        src: "{{ workspace_root }}/{{ benchmark_source_dir }}/reports/"
        dest: "{{ workspace_root }}/reports/"
        mode: push
        delete: no
        recursive: yes
      delegate_to: "{{ inventory_hostname }}"
      register: reports_sync_result
      failed_when: false

    - name: Warn if reports sync failed
      ansible.builtin.debug:
        msg: "⚠️  WARNING: Failed to sync reports directory. Reports may be incomplete. Check: {{ workspace_root }}/{{ benchmark_source_dir }}/reports/"
      when: reports_sync_result.failed | default(false)

    - name: Copy logs artifacts from gas-benchmarks to top-level
      ansible.builtin.synchronize:
        src: "{{ workspace_root }}/{{ benchmark_source_dir }}/logs/"
        dest: "{{ workspace_root }}/logs/"
        mode: push
        delete: no
        recursive: yes
      delegate_to: "{{ inventory_hostname }}"
      register: logs_sync_result
      failed_when: false

    - name: Warn if logs sync failed
      ansible.builtin.debug:
        msg: "⚠️  WARNING: Failed to sync logs directory. Logs may be incomplete. Check: {{ workspace_root }}/{{ benchmark_source_dir }}/logs/"
      when: logs_sync_result.failed | default(false)

    - name: Log artifact collection summary
      ansible.builtin.debug:
        msg: |
          Artifact collection completed:
          - Results: {{ 'copied' if results_sync_result.changed else ('FAILED' if results_sync_result.failed | default(false) else 'no changes') }}
          - Reports: {{ 'copied' if reports_sync_result.changed else ('FAILED' if reports_sync_result.failed | default(false) else 'no changes') }}
          - Logs: {{ 'copied' if logs_sync_result.changed else ('FAILED' if logs_sync_result.failed | default(false) else 'no changes') }}

    - name: Fetch artifacts to local machine (remote execution only)
      when: inventory_hostname != 'localhost' and inventory_hostname != '127.0.0.1'
      block:
        - name: Ensure local results directory exists
          ansible.builtin.file:
            path: "{{ local_artifacts_dir }}/results"
            state: directory
            mode: '0755'
          delegate_to: localhost

        - name: Ensure local reports directory exists
          ansible.builtin.file:
            path: "{{ local_artifacts_dir }}/reports"
            state: directory
            mode: '0755'
          delegate_to: localhost

        - name: Ensure local logs directory exists
          ansible.builtin.file:
            path: "{{ local_artifacts_dir }}/logs"
            state: directory
            mode: '0755'
          delegate_to: localhost

        - name: Fetch results from remote to local
          ansible.posix.synchronize:
            src: "{{ workspace_root }}/results/"
            dest: "{{ local_artifacts_dir }}/results/"
            mode: pull
            recursive: yes
          delegate_to: localhost
          register: fetch_results
          failed_when: false

        - name: Fetch reports from remote to local
          ansible.posix.synchronize:
            src: "{{ workspace_root }}/reports/"
            dest: "{{ local_artifacts_dir }}/reports/"
            mode: pull
            recursive: yes
          delegate_to: localhost
          register: fetch_reports
          failed_when: false

        - name: Fetch logs from remote to local
          ansible.posix.synchronize:
            src: "{{ workspace_root }}/logs/"
            dest: "{{ local_artifacts_dir }}/logs/"
            mode: pull
            recursive: yes
          delegate_to: localhost
          register: fetch_logs
          failed_when: false

        - name: Log remote artifact fetch summary
          ansible.builtin.debug:
            msg: |
              Remote artifacts fetched to {{ local_artifacts_dir }}/:
              - Results: {{ 'fetched' if fetch_results.changed else 'no changes' }}
              - Reports: {{ 'fetched' if fetch_reports.changed else 'no changes' }}
              - Logs: {{ 'fetched' if fetch_logs.changed else 'no changes' }}
