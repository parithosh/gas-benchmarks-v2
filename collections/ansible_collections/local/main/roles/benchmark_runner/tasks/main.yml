---
# Role: benchmark_runner
# Description: Executes gas benchmarks for a single client using run.sh script

- name: Execute benchmark for {{ client_name }}
  block:
    - name: Generate images JSON for client
      ansible.builtin.set_fact:
        client_images_json: "{{ {client_name: benchmark_images[client_name] | default('default')} | to_json }}"

    - name: Convert test paths to JSON
      ansible.builtin.set_fact:
        test_paths_json: "{{ benchmark_test_paths | to_json }}"

    - name: Build run.sh command
      ansible.builtin.set_fact:
        run_command: >-
          bash src/run.sh
          -T '{{ test_paths_json }}'
          -c {{ client_name }}
          -r {{ benchmark_runs }}
          -i '{{ client_images_json }}'
          {{ '-w ' + benchmark_warmup_file if (benchmark_warmup_file is defined and benchmark_warmup_file != '') else '' }}
          {{ '-f ' + benchmark_filter if (benchmark_filter is defined and benchmark_filter != '') else '' }}
          {{ '-n ' + benchmark_network if (benchmark_network is defined and benchmark_network != '') else '' }}
          {{ '-B ' + benchmark_snapshot_root if (benchmark_snapshot_root is defined and benchmark_snapshot_root != '') else '' }}
          {{ '-R' if benchmark_restart_before_testing | default(false) else '' }}
          {{ '-F' if benchmark_skip_forkchoice | default(false) else '' }}
          {{ '-o ' + benchmark_opcodes_warmup_count | string if (benchmark_opcodes_warmup_count is defined and benchmark_opcodes_warmup_count > 0) else '' }}
          {{ '-d' if benchmark_debug | default(false) else '' }}

    - name: Display run command
      ansible.builtin.debug:
        msg: "Executing: {{ run_command }}"
      when: benchmark_debug | default(false)

    - name: Execute benchmark run
      ansible.builtin.shell: "{{ run_command }}"
      args:
        chdir: "{{ workspace_root }}"
        executable: /bin/bash
      environment:
        JWT_PATH: "{{ benchmark_jwt_path }}"
      register: run_result
      changed_when: true

    - name: Check if benchmark succeeded
      ansible.builtin.assert:
        that:
          - run_result.rc == 0
        fail_msg: "Benchmark execution failed for {{ client_name }}: {{ run_result.stderr }}"
        success_msg: "Benchmark execution succeeded for {{ client_name }}"

    - name: Register client success
      ansible.builtin.set_fact:
        client_execution_status:
          client: "{{ client_name }}"
          status: "success"
          return_code: "{{ run_result.rc }}"
          stdout: "{{ run_result.stdout }}"

  rescue:
    - name: Log benchmark failure
      ansible.builtin.debug:
        msg: "Failed to execute benchmarks for {{ client_name }}: {{ ansible_failed_result.msg | default('Unknown error') }}"

    - name: Register client failure
      ansible.builtin.set_fact:
        client_execution_status:
          client: "{{ client_name }}"
          status: "failed"
          error_message: "{{ ansible_failed_result.msg | default('Unknown error') }}"
          return_code: "{{ run_result.rc | default(-1) }}"
          stderr: "{{ run_result.stderr | default('') }}"

    - name: Mark this client as failed
      ansible.builtin.fail:
        msg: "Benchmark execution failed for {{ client_name }}"

  always:
    - name: Collect Docker logs for client
      ansible.builtin.shell: |
        set -e
        log_dir="{{ workspace_root }}/{{ benchmark_logs_dir }}/{{ client_name }}"
        mkdir -p "$log_dir"

        # Get list of containers for this client
        containers=$(docker ps -a --filter "name={{ client_name }}" --format "{{ '{{' }}.Names{{ '}}' }}" 2>/dev/null || true)

        if [ -n "$containers" ]; then
          for container in $containers; do
            echo "Collecting logs for container: $container"
            docker logs "$container" > "$log_dir/${container}.log" 2>&1 || true
          done
          echo "Logs collected for {{ client_name }}"
        else
          echo "No containers found for {{ client_name }}"
        fi
      args:
        executable: /bin/bash
      register: log_collection_result
      changed_when: "'Logs collected' in log_collection_result.stdout"
      failed_when: false
