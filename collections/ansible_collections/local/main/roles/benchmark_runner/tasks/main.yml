---
# Role: benchmark_runner
# Description: Executes gas benchmarks for a single client using run.sh script

- name: Execute benchmark for {{ client_name }}
  block:
    - name: Extract test path from first test (simplified for single path)
      ansible.builtin.set_fact:
        primary_test_path: "{{ benchmark_test_paths[0].path | regex_replace('^' + benchmark_tests_root + '/', '') }}"
        primary_genesis: "{{ benchmark_test_paths[0].genesis | default('') }}"

    - name: Build run.sh command (using legacy -t format)
      ansible.builtin.set_fact:
        run_command: >-
          bash run.sh
          -t "{{ primary_test_path }}"
          {{ '-g ' + primary_genesis if primary_genesis != '' else '' }}
          -c "{{ client_name }}"
          -r {{ benchmark_runs }}
          {{ '-w "' + benchmark_warmup_file + '"' if (benchmark_warmup_file is defined and benchmark_warmup_file != '') else '' }}
          {{ '-f "' + benchmark_filter + '"' if (benchmark_filter is defined and benchmark_filter != '') else '' }}
          {{ '-n "' + benchmark_network + '"' if (benchmark_network is defined and benchmark_network != '') else '' }}
          {{ '-B "' + benchmark_snapshot_root + '"' if (benchmark_snapshot_root is defined and benchmark_snapshot_root != '') else '' }}
          {{ '-R' if benchmark_restart_before_testing | default(false) else '' }}
          {{ '-F' if benchmark_skip_forkchoice | default(false) else '' }}
          {{ '-o ' + benchmark_opcodes_warmup_count | string if (benchmark_opcodes_warmup_count is defined and benchmark_opcodes_warmup_count > 0) else '' }}

    - name: Display run command
      ansible.builtin.debug:
        msg: "Executing: {{ run_command }}"

    - name: Execute benchmark run
      ansible.builtin.shell: "{{ run_command }}"
      args:
        chdir: "{{ workspace_root }}/{{ benchmark_source_dir }}"
        executable: /bin/bash
      environment:
        JWT_PATH: "{{ benchmark_jwt_path }}"
        PYTHONPATH: "{{ workspace_root }}/{{ benchmark_source_dir }}"
      register: run_result
      changed_when: true

    - name: Check if benchmark succeeded
      ansible.builtin.assert:
        that:
          - run_result.rc == 0
        fail_msg: "Benchmark execution failed for {{ client_name }}: {{ run_result.stderr }}"
        success_msg: "Benchmark execution succeeded for {{ client_name }}"

    - name: Register client success
      ansible.builtin.set_fact:
        client_execution_status:
          client: "{{ client_name }}"
          status: "success"
          return_code: "{{ run_result.rc }}"
          stdout: "{{ run_result.stdout }}"

  rescue:
    - name: Log benchmark failure
      ansible.builtin.debug:
        msg: "Failed to execute benchmarks for {{ client_name }}: {{ ansible_failed_result.msg | default('Unknown error') }}"

    - name: Register client failure
      ansible.builtin.set_fact:
        client_execution_status:
          client: "{{ client_name }}"
          status: "failed"
          error_message: "{{ ansible_failed_result.msg | default('Unknown error') }}"
          return_code: "{{ run_result.rc | default(-1) }}"
          stderr: "{{ run_result.stderr | default('') }}"

    - name: Mark this client as failed
      ansible.builtin.fail:
        msg: "Benchmark execution failed for {{ client_name }}"

  always:
    - name: Collect Docker logs for client
      ansible.builtin.shell: |
        set -e
        log_dir="{{ workspace_root }}/{{ benchmark_logs_dir }}/{{ client_name }}"
        mkdir -p "$log_dir"

        # Get list of containers for this client
        containers=$(docker ps -a --filter "name={{ client_name }}" --format "{{ '{{' }}.Names{{ '}}' }}" 2>/dev/null || true)

        if [ -n "$containers" ]; then
          for container in $containers; do
            echo "Collecting logs for container: $container"
            docker logs "$container" > "$log_dir/${container}.log" 2>&1 || true
          done
          echo "Logs collected for {{ client_name }}"
        else
          echo "No containers found for {{ client_name }}"
        fi
      args:
        executable: /bin/bash
      register: log_collection_result
      changed_when: "'Logs collected' in log_collection_result.stdout"
      failed_when: false
